# C-Collections
A small library of C "template" data structures.

[Array.h](#arrayh)

[LinkedList.h](#linkedlisth)

[DoubleLinkedList.h](#doublelinkedlisth)

[TODO](#todo)

So this is really just a library of common data structures that i otherwise find myself rewriting all the time.
Most of the data structures are implemented with a *kind of* template-engine using macros to generate code for a specific type.
The containers also have foreach loops, they too implemented with macros.
Everything in here covers only basic functionality.

----

# Array.h
A dynamic array. As with any array random indexing is fast, adding elements will usually be O(1), but not when it needs to expand the underlying array.

    Exposes functions:
    
        - init_array(Type)
            Macro to generate code for an array containing elements of type Type. E.g init_array(int) will generate the type Array_int along with functions for Array_int,
            like array_int_new(), and array_int_push()
            
        - array_Type_new()
            Returns empty Array of Type with initial capacity of 16 elements
            
        - array_Type_hash(const Array_Type*)
            Returns 32 bit hash value generated from running murmurhash on the underlying array of elements
            
        - array_Type_free(Array_Type*)
            Frees underlying array, and sets everything to 0
            
        - array_Type_copy(const Array_Type*)
            Returns deep copy of the Array passed as argument
            
        - array_Type_expand(Array_Type*)
            Doubles the capacity of the array. Really shouldn't be used since the array handles this automatically, but it's there...
            
        - array_Type_push(Array_Type*, const Type)
            Pushes item to the back of the Array, expands if neccessary
            
        - array_foreach(Type, array, lambda)
            Macro that loops through all elements in array and calls lambda, passing them as argument
            lambda should be a function or macro taking a single parameter of type Type.
            array should be the Array_Type to iterate over.
            Type is not actually used, but included for consistency with the other data types
            
----

# LinkedList.h
A linked list, first in first out. Pushing and popping elements will always be O(1), does not implement random indexing.

    Exposes functions:
        
        - init_list(Type)
            Macro to generate code for a List for type Type. E.g init_list(int) will generate code for List_int along with functions for List_int such as list_int_new(), 
            and list_int_push()
            
        - list_Type_new()
            Returns an empty List of Type
            
        - list_Type_copy(const List_Type*)
            Returns a deep copy of the List passed as argument
           
        - list_Type_push(List_Type*, const Type)
            Pushes the passed item to the back of the list
            
        - list_Type_pop(List_Type*, Type*)
            Will copy the first item in the List into the pointer and remove it from the List, returns true if an item was successfully popped
            
        - list_Type_peek(const List_Type, Type*)
            Will copy the first item in the List into the pointer
            
        - list_Type_to_array(const List_Type*)
            Will return a newly allocated array containing all elements in the List in order. Returns a NULL pointer if List is empty
            
        - list_Type_hash(const List_Type*)
            Returns 32 bit hash generated by xor:ing together the individual murmur-hashes of all items in the List
            
        - list_Type_free(List_Type*)
            Frees any resources used by the List, and sets everything to 0
            
        - list_foreach(Type, list, lambda)
            Iterates over all elements in the List and calls lambda with each as argument.
            Type should be the type of items in the list
            list is the list to iterate over
            lambda should be a function or macro taking a single argument of Type
            
----

# DoubleLinkedList.h
Provides an implementation of a doubly linked list. I've called the type BiList, as in Bi-directional List to make it easier to type over and over...
As with any linked list, pushing or popping will be O(1), and it does not implement random indexing. 
The big difference from the normal LinkedList is that this BiList supports pushing/popping at front and back, as well as some reversing operations.

    Exposes functions:
        
        - init_bilist(Type)
            Generates code for a doubly linked list containing type Type, BiList_Type, along with functions for the BiList such as bilist_Type_new()
            
        - bilist_Type_new()
            Returns an empty BiList_Type
            
        - bilist_Type_copy(const BiList_Type*)
            Returns a deep copy of the passed BiList
            
        - bilist_Type_push_front(BiList_Type*, const Type)
            Pushes the passed item to front of the BiList
            
        - bilist_Type_push_back(BiList_Type*, const Type)
            Pushes the passed item to back of the BiList
        
        - bilist_Type_pop_front(BiList_Type*, Type*)
            Copies the first item in the BiList into the Type pointer, and removes it from the BiList. Returns true if the operation was successful
            
        - bilist_Type_pop_back(BiList_Type*, Type*)
            Copies the last item in the BiList into the Type pointer, and removes it from the BiList. Returns true if the operation was successful
            
        - bilist_Type_first(const BiList_Type*, Type*)
            Copies the first element in BiList into the Type pointer, if it exists
            
        - bilist_Type_last(const BiList_Type*, Type*)
            Copies the lase element in BiList into the Type pointer, if it exists
            
        - bilist_Type_to_array(const BiList_Type*)
            Returns a newly allocated array consisting of the items in the BiList, in order
            
        - bilist_Type_to_array_reversed(const BiList_Type*)
            Returns a newly allocated array consisting of the items in the BiList, in reversed order
            
        - bilist_Type_hash(const BiList_Type*)
            Returns 32 bit hash generated by xoring the murmur-hashes of each item together
            
        - bilist_Type_free(BiList_Type*)
            Frees any resources used by the BiList, and sets everything to 0
            
        - bilist_foreach(Type, list, lambda)
            Iterates over the BiList and calls lambda with each element in order.
            Type should be the type of the elements stored in the list.
            list is the list to iterate over
            lambda should be a function or macro taking a single parameter of Type
        
        - bilist_foreach_reverse(Type, list, lambda)
            Iterates over the BiList and calls lambda with each element in reverse order.
            Type should be the type of the elements stored in the list.
            list is the list to iterate over
            lambda should be a function or macro taking a single parameter of Type
    
# TODO
  - Double Linked List
  - Priority Queue
  - HashMap
  - HashSet
  - Some kind of Tree Map
  - Some kind of Tree Set
